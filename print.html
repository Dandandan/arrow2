<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>arrow 2 documentation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Arrow2</a></li><li class="chapter-item expanded "><a href="arrow.html"><strong aria-hidden="true">2.</strong> The arrow format</a></li><li class="chapter-item expanded "><a href="low_level.html"><strong aria-hidden="true">3.</strong> Low level API</a></li><li class="chapter-item expanded "><a href="high_level.html"><strong aria-hidden="true">4.</strong> High level API</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">arrow 2 documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="arrow2"><a class="header" href="#arrow2">Arrow2</a></h1>
<p>Arrow2 is a Rust library that implements data structures and functionality enabling
interoperability with the arrow format.</p>
<p>The typical use-case for this library is to perform CPU and memory-intensive analytics in a format that supports heterogeneous data strutures, null values, and IPC and FFI interfaces across languages.</p>
<p>Arrow2 is divided in two main parts: a <a href="./low_end.html">low-end API</a> to efficiently
operate with contiguous memory regions, and a <a href="./high_end.html">high-end API</a> to operate with
arrow arrays, logical types, schemas, etc.</p>
<p>This repo started as an experiment forked from the Apache arrow project to offer a transmute-free
Rust implementation of that crate. It currently offers most functionality with the notable exception of reading and writing to and from parquet.</p>
<h1 id="arrow"><a class="header" href="#arrow">Arrow</a></h1>
<p><a href="https://arrow.apache.org/">Arrow</a> as in-memory columnar format for modern analytics that natively supports the concept of a null value, nested structs, and many others.</p>
<p>It has an IPC protocol (based on flat buffers) and a stable C-represented ABI for intra-process communication via foreign interfaces (FFI).</p>
<p>The arrow format recommends allocating memory along cache lines to leverage modern archtectures,
as well as using a shared memory model that enables multi-threading.</p>
<h1 id="low-end-api"><a class="header" href="#low-end-api">Low end API</a></h1>
<p>The starting point of this crate is the idea that data must be stored in memory in a specific arrangement to be interoperable with Arrow's ecosystem. With this in mind, this crate
does not use <code>Vec</code>, and instead has its own containers to store data, including to share and consume it via FFI.</p>
<p>The most important design decision of this crate is that contiguous regions are shared via an <code>Arc</code>. In this context, the operation of slicing a memory region is <code>O(1)</code> because it corresponds to changing an offset and length. The tradeoff is that once under and <code>Arc</code>, memory regions are imutable.</p>
<p>The second important aspect is that Arrow has two main types of data buffers: bitmaps, whose offsets are measured in bits, and byte types (such as <code>i23</code>), whose offsets are measured in bytes. With this in mind, this crate has 2 main types of containers of contiguous memory regions:</p>
<ul>
<li><code>Buffer&lt;T&gt;</code>: handle contigous memory regions of type T whose offsets are measured in items</li>
<li><code>Bitmap</code>: handle contigous memory regions of bits whose offsets are measured in bits</li>
</ul>
<p>These hold <em>all</em> data-related memory in this crate.</p>
<p>Due to their intrinsic imutability, each container has a corresponding mutable (and non-sharable) variant:</p>
<ul>
<li><code>MutableBuffer&lt;T&gt;</code></li>
<li><code>Buffer&lt;T&gt;</code></li>
<li><code>MutableBitmap</code></li>
<li><code>Bitmap</code></li>
</ul>
<p>Some examples:</p>
<p>Create a new <code>Buffer&lt;u32&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use arrow2::buffer::Buffer;
</span><span class="boring">fn main() {
</span>let x = Buffer::from(&amp;[1u32, 2, 3]);
assert_eq!(x.as_slice(), &amp;[1u32, 2, 3]);

let x = x.slice(1, 2);
assert_eq!(x.as_slice(), &amp;[2, 3]);
<span class="boring">}
</span></code></pre></pre>
<p>Using a <code>MutableBuffer&lt;f64&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use arrow2::buffer::{Buffer, MutableBuffer};
</span><span class="boring">fn main() {
</span>let mut x = MutableBuffer::with_capacity(4);
(0..3).for_each(|i| {
    x.push(i as f64)
});
let x: Buffer&lt;f64&gt; = x.into();
assert_eq!(x.as_slice(), &amp;[0.0, 1.0, 2.0]);
<span class="boring">}
</span></code></pre></pre>
<p>In this context, <code>MutableBuffer</code> is the closest API to rust's <code>Vec</code>.</p>
<p>The following demonstrates how to efficiently 
perform an operation from an iterator of <a href="https://doc.rust-lang.org/std/iter/trait.TrustedLen.html">TrustedLen</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::iter::FromIterator;
</span><span class="boring">use arrow2::buffer::{Buffer, MutableBuffer};
</span><span class="boring">fn main() {
</span>let x = Buffer::from_iter((0..1000));
let iter = x.as_slice().iter().map(|x| x * 2);
let y = unsafe { Buffer::from_trusted_len_iter(iter) };
assert_eq!(y.as_slice()[50], 100);
<span class="boring">}
</span></code></pre></pre>
<p>Using <code>from_trusted_len_iter</code> often causes the compiler to auto-vectorize.</p>
<p>We will now see how these containers are used in higher-level structures: Arrays.</p>
<h1 id="high-end-api"><a class="header" href="#high-end-api">High end API</a></h1>
<p>The simplest way to think about an arrow <code>Array</code> is that it represents 
<code>Vec&lt;Option&lt;T&gt;&gt;</code> and has a logical type associated with it.</p>
<p>Probably the simplest array in this crate is <code>PrimitiveArray&lt;T&gt;</code>. It can be constructed
from an iterator as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use arrow2::array::{Array, PrimitiveArray, Primitive};
</span><span class="boring">use arrow2::datatypes::DataType;
</span><span class="boring">fn main() {
</span>let array: PrimitiveArray&lt;i32&gt; = [Some(1), None, Some(123)]
    .iter()
    .collect::&lt;Primitive&lt;i32&gt;&gt;()
    .to(DataType::Int32);
assert_eq!(array.len(), 3)
<span class="boring">}
</span></code></pre></pre>
<p>A <code>PrimitiveArray</code> has 3 components:</p>
<ol>
<li>A physical type (<code>i32</code>)</li>
<li>A logical type (<code>DataType::Int32</code>)</li>
<li>Data</li>
</ol>
<p>Its main difference vs a <code>Vec&lt;Option&lt;T&gt;&gt;</code> are:</p>
<ul>
<li>Its data is layed out in memory as a <code>Buffer&lt;T&gt;</code> and a <code>Option&lt;Bitmap&gt;</code>.</li>
<li><code>PrimitivArray&lt;T&gt;</code> has an associated logical datatype.</li>
</ul>
<p>The first difference allows interoperability with Arrow's ecosystem and efficient SIMD operations (we will re-visit this below); the second difference is that it allows semantic meaning to the array. In the example</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use arrow2::array::Primitive;
</span><span class="boring">use arrow2::datatypes::DataType;
</span><span class="boring">fn main() {
</span>let ints = Primitive::&lt;i32&gt;::from(&amp;[Some(1), None]).to(DataType::Int32);
let dates = Primitive::&lt;i32&gt;::from(&amp;[Some(1), None]).to(DataType::Date32);
<span class="boring">}
</span></code></pre></pre>
<p><code>ints</code> and <code>dates</code> have the same in-memory representation but different logic representations (e.g. dates are usually represented as a string).</p>
<p>The following arrays are supported:</p>
<ul>
<li><code>NullArray</code> (just holds nulls)</li>
<li><code>BooleanArray</code> (booleans)</li>
<li><code>PrimitiveArray&lt;T&gt;</code> (for ints, floats)</li>
<li><code>Utf8Array&lt;i32&gt;</code> and <code>Utf8Array&lt;i64&gt;</code> (for strings)</li>
<li><code>BinaryArray&lt;i32&gt;</code> and <code>BinaryArray&lt;i64&gt;</code> (for opaque binaries)</li>
<li><code>FixedSizeBinaryArray</code> (like <code>BinaryArray</code>, but fixed size)</li>
<li><code>ListArray&lt;i32&gt;</code> and <code>ListArray&lt;i64&gt;</code> (nested arrays)</li>
<li><code>FixedSizeListArray</code> (nested arrays of fixed size)</li>
<li><code>StructArray</code> (when each row has different logical types)</li>
<li><code>DictionaryArray&lt;K&gt;</code> (nested array with encoded values)</li>
</ul>
<h2 id="dynamic-array"><a class="header" href="#dynamic-array">Dynamic Array</a></h2>
<p>There is a more powerful aspect of arrow arrays, and that is that they all
implement the trait <code>Array</code> and can be casted to <code>&amp;dyn Array</code>, i.e. they can be turned into
a trait object. This enables arrays to have types that are dynamic in nature.
<code>ListArray&lt;i32&gt;</code> is an example of a nested (dynamic) array:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::sync::Arc;
</span><span class="boring">use arrow2::array::{Array, ListPrimitive, ListArray, Primitive};
</span><span class="boring">use arrow2::datatypes::DataType;
</span><span class="boring">fn main() {
</span>let data = vec![
    Some(vec![Some(1i32), Some(2), Some(3)]),
    None,
    Some(vec![Some(4), None, Some(6)]),
];

let a: ListArray&lt;i32&gt; = data
    .into_iter()
    .collect::&lt;ListPrimitive&lt;i32, Primitive&lt;i32&gt;, i32&gt;&gt;()
    .to(ListArray::&lt;i32&gt;::default_datatype(DataType::Int32));

let inner: &amp;Arc&lt;dyn Array&gt; = a.values();
<span class="boring">}
</span></code></pre></pre>
<p>Note how we have not specified the the inner type explicitely in the signature <code>ListArray&lt;i32&gt;</code>.
Instead, <code>ListArray</code> has an inner <code>Array</code> representing all its values (available via <code>.values()</code>).</p>
<h3 id="downcast-and-as_any"><a class="header" href="#downcast-and-as_any">Downcast and <code>as_any</code></a></h3>
<p>Given a trait object <code>&amp;dyn Array</code>, we know its logical type via <code>Array::data_type()</code> and can use it to downcast the array to its concrete type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use arrow2::array::{Array, PrimitiveArray, Primitive};
</span><span class="boring">use arrow2::datatypes::DataType;
</span><span class="boring">fn main() {
</span>let array: PrimitiveArray&lt;i32&gt; = [Some(1), None, Some(123)]
    .iter()
    .collect::&lt;Primitive&lt;i32&gt;&gt;()
    .to(DataType::Int32);
let array = &amp;array as &amp;dyn Array;

let array = array.as_any().downcast_ref::&lt;PrimitiveArray&lt;i32&gt;&gt;().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>There is a many to one relationship between <code>DataType</code> and a physical type (like <code>i32</code>). These are typically encapsulated on <code>match</code> patterns.</p>
<h2 id="from-iterator"><a class="header" href="#from-iterator">From Iterator</a></h2>
<p>In the code above, we've introduced how to create an array from an iterator.
These APIs are avaiable for all Arrays, and they are highly suitable to efficiently
create them. In this section we will go a bit more in detail about these operations,
and how to make them even more efficient.</p>
<p>This crate's APIs are generally split in two parts: whether an operation leverages contiguous memory regions or whether it does not.</p>
<p>If yes, then use:</p>
<ul>
<li><code>Buffer::from_iter</code></li>
<li><code>unsafe Buffer::from_trusted_len_iter</code></li>
<li><code>unsafe Buffer::try_from_trusted_len_iter</code></li>
</ul>
<p>If not, then use the builder API, such as <code>Primitive&lt;T&gt;</code>, <code>Utf8Primitive&lt;O&gt;</code>, <code>ListPrimitive</code>, etc.</p>
<p>We have seen examples where the latter API was used. In the last example of this page you will be introduced to an example of using the former for SIMD.</p>
<h2 id="into-iterator"><a class="header" href="#into-iterator">Into Iterator</a></h2>
<p>We've already seen how to create an array from an iterator. Most arrays also implement
<code>IntoIterator</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use arrow2::array::{Array, PrimitiveArray, Primitive};
</span><span class="boring">use arrow2::datatypes::DataType;
</span><span class="boring">fn main() {
</span>let array: PrimitiveArray&lt;i32&gt; = [Some(1), None, Some(123)]
    .iter()
    .collect::&lt;Primitive&lt;i32&gt;&gt;()
    .to(DataType::Int32);

for item in array.iter() {
    if let Some(value) = item {
        println!(&quot;{}&quot;, value);
    } else {
        println!(&quot;NULL&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Like <code>FromIterator</code>, this crate contains two sets of APIs to iterate over data. Let's say
that you have an array <code>array: &amp;PrimitiveArray&lt;T&gt;</code>. The following applies:</p>
<ol>
<li>If you need to iterate over <code>Option&lt;T&gt;</code>, use <code>array.iter()</code></li>
<li>If you can operate over the values and validity independently, use <code>array.values() -&gt; &amp;[T]</code> and <code>array.validity() -&gt; &amp;Option&lt;Bitmap&gt;</code></li>
</ol>
<p>Note that case 1 is useful when e.g. you want to perform an operation that depends on both validity and values, while the latter is suitable for SIMD and copies, as they return contiguous memory regions (slices and bitmaps). We will see below how to leverage these APIs.</p>
<p>This idea holds more generally in this crate: <code>values()</code> always returns something that has a contiguous in-memory representation, while <code>iter()</code> returns items taking validity into account. To get an iterator over contiguous values, use <code>array.values().iter()</code>.</p>
<p>There is one last API that is worth mentioning, and that is <code>Bitmap::chunks</code>. When performing
bitwise operations, it is often more performant to operate on chunks of bits instead of single bits. <code>chunks</code> offers a <code>TrustedLen</code> of <code>u64</code> with the bits + an extra <code>u64</code> remainder. We expose two functions, <code>unary(Bitmap, Fn) -&gt; Bitmap</code> and <code>binary(Bitmap, Bitmap, Fn) -&gt; Bitmap</code> that use this API to efficiently perform bitmap operations.</p>
<h2 id="vectorized-operations"><a class="header" href="#vectorized-operations">Vectorized operations</a></h2>
<p>One of the main advantages of the arrow format and its memory layout is that 
it often enables SIMD. For example, an unary operation <code>op</code> on a <code>PrimitiveArray</code> is likely auto-vectorized on the following code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use arrow2::buffer::Buffer;
</span><span class="boring">use arrow2::{
</span><span class="boring">    array::{Array, PrimitiveArray},
</span><span class="boring">    types::NativeType,
</span><span class="boring">    datatypes::DataType,
</span><span class="boring">};
</span>
pub fn unary&lt;I, F, O&gt;(array: &amp;PrimitiveArray&lt;I&gt;, op: F, data_type: &amp;DataType) -&gt; PrimitiveArray&lt;O&gt;
where
    I: NativeType,
    O: NativeType,
    F: Fn(I) -&gt; O,
{
    let values = array.values().iter().map(|v| op(*v));
    //  Soundness
    //      `values` is an iterator with a known size because arrays are sized.
    let values = unsafe { Buffer::from_trusted_len_iter(values) };

    PrimitiveArray::&lt;O&gt;::from_data(data_type.clone(), values, array.validity().clone())
}
<span class="boring">}
</span></code></pre></pre>
<p>Some notes:</p>
<ol>
<li>
<p>We used <code>array.values()</code>, as described above: this operation leverages a contiguous memory region.</p>
</li>
<li>
<p>We leveraged normal rust iterators for the operation.</p>
</li>
<li>
<p>We have used <code>from_trusted_len_iter</code>, which assumes that the iterator is <a href="https://doc.rust-lang.org/std/iter/trait.TrustedLen.html"><code>TrustedLen</code></a>. This (instead of <code>.collect</code>) is necessary because trait specialization is currently unstable.</p>
</li>
<li>
<p>We used <code>op</code> on the array's values irrespectively of their validity,
and cloned its validity. This approach is suitable for operations whose branching off is more expensive than operating over all values. If the operation is expensive, then using <code>Primitive::&lt;O&gt;::from_trusted_len_iter</code> is likely faster.</p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
